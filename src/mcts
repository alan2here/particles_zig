const JOBS = 2000;
const DEPTH = 500;
const BUCKETS = 1_000_000;

const Decision = enum {
    Extend,
    Contract,
};

// globals (shared between all jobs)
const all_wins : [BUCKETS]uint;
const all_games : [BUCKETS]uint;

fn hash(decisions: []Decision) {
    h = 0
    for decision in decisions:
        h = hashcombine(0, decision)
    // 0..buckets-1 as output
}

fn decide(job_id, node, depth) {
    h = hash(node)
    wins = all_wins[h]
    games = all_games[h]
    ratio = wins/games

    rng using job_id and node and depth
    OR
    seed initially with job_id
    then use same rng

    maybe we dont need node

    weight using ratio
}

fn hash(node) { // Maybe take depth, depending on duplicate node policy
    use some hash
}

fn step(*node, decision) {
    // apply decision to node (using switch statement)
}

root = current game state
for (0..JOBS) |job_id| {
    branches = array of decision enums, DEPTH items +- 1
    node = copy_of(root)
    var decisions = [DEPTH]Decision;
    for 0..DEPTH |depth| {
        decision = decide(job_id, node, depth)
        decisions[depth] = decision
        step(node, decision)
    }
}
